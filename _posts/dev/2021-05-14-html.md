---
title: HTML
date: 2021-05-14T01:07:00.407Z
---

# [How to lazy load images and iframes with the native HTML loading attribute](https://gomakethings.com/how-to-lazy-load-images-and-iframes-with-the-native-html-loading-attribute/)

<details>

Syntax

```HTML
<img src="URL" loading="eager|lazy">
```

- eager: Default. Loads an image immediately
- lazy: Defer loading of images until some conditions are met

</details>

# [Accessibility is hard. It's also your job.](https://gomakethings.com/accessibility-is-hard.-its-also-your-job./)

<details>

- Accessibility is more than just screen reader support. It’s users with neuromuscular conditions, cognitive conditions, and more!
- People with disabilities are not a monolith. Among people who use screen readers, some will be more technically savvy than others. They will use the software in a variety of different ways. They will have varying degrees of visual impairment. Accordingly, their needs and expectations may be different.
- Screen readers and other accessibility technology have IE6-era levels of cross-browser/cross-platform consistency. When I write JS or CSS these days, I rarely need to worry about browser support. Not so with accessibility practices! Different screen readers are designed to work best with specific browsers and OS’s, and don’t always adhere properly or fully to the spec.
- Good advice is hard to come by. [The spec documents](https://www.w3.org/WAI/fundamentals/accessibility-intro/) are dense and hard to read. Articles by arm-charm accessibility allies are often wrong or fail to capture nuance. I’ve been wrong about dropdown menus and about subheaders. The dropdown menu approach? I got that from the GitHub website. They got it wrong, too.

What I’d love to see more of are native accessible elements that make this easier, for things like…

- Toggle tabs (ex. `<tab>` and `<tabcontent>`)
- Dropdown menus (ex. `<dropdown>` and `<summary>`, like the `<details>`/`<summary>` elements)
- Modals (as in a `<dialog>` element that actually works!)
- Photo galleries and carousels (ex. `<gallery>` and `<galleryitem>`)

</details>

# [Web Components](https://developer.mozilla.org/en-US/docs/Web/Web_Components)

<details>
Web Components aims to solve such problems — it consists of three main technologies, which can be used together to create versatile custom elements with encapsulated functionality that can be reused wherever you like without fear of code collisions.

- Custom elements: A set of JavaScript APIs that allow you to define custom elements and their behavior, which can then be used as desired in your user interface.
- Shadow DOM: A set of JavaScript APIs for attaching an encapsulated "shadow" DOM tree to an element — which is rendered separately from the main document DOM — and controlling associated functionality. In this way, you can keep an element's features private, so they can be scripted and styled without the fear of collision with other parts of the document.
- HTML templates: The `<template>` and `<slot>` elements enable you to write markup templates that are not displayed in the rendered page. These can then be reused multiple times as the basis of a custom element's structure.

The basic approach for implementing a web component generally looks something like this:

1. Create a class in which you specify your web component functionality, using the ECMAScript 2015 class syntax (see [Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) for more information).
2. Register your new custom element using the [`CustomElementRegistry.define()`](https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define) method, passing it the element name to be defined, the class or function in which its functionality is specified, and optionally, what element it inherits from.
3. If required, attach a shadow DOM to the custom element using [`Element.attachShadow()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow) method. Add child elements, event listeners, etc., to the shadow DOM using regular DOM methods.
4. If required, define an HTML template using [`<template>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template) and [`<slot>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot). Again use regular DOM methods to clone the template and attach it to your shadow DOM.
5. Use your custom element wherever you like on your page, just like you would any regular HTML element.

## Tutorials

- [Using custom elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements)
- [Using shadow DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM)
- [Using templates and slots](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots)

</details>
